# 让世界舞动

在上一篇中我们可以了解到如何渲染一份静态内容，但是仅仅渲染静态内容并不能作为一个完整的框架。而在本章节所探讨的内容便是如何让静态的内容动起来。

## 插值表达式

在开始之前，需要先了解一个关键的概念，**「插值表达式」**。
它是几乎所有前端框架的核心概念，没有任何一个框架能够摆脱这个。
没有它，所有的模板都只能是静态的不可变更的，它是让模板强大起来最最重要的概念。

有了它，可以在一段纯静态文本中插入动态的逻辑，包括但不限于渲染变量、渲染表达式、控制模板结构等等功能。

在不同的框架下，差值表达式通常用一堆特殊的标记包裹，而不同框架所使用的的标记也不尽相同，例如：

- React 以及大部分使用 JSX 的框架中使用 `{` 和 `}` 来插入表达式，例如 `<div>{name}</div>`
- Vue 中使用 `{{` 和 `}}` 来插入表达式，例如 `<div>{{name}}</div>`
- Lit 中因为采用了 ES6 的 template literal 语法，所以自然而言使用了 `${` 和 `}` 去插入表达式，例如 `<div>${name}</div>`。严格来说这个已经不能叫作差值表达式。

<md-todo>这里应该补充上述多个框架的对比代码</md-todo>

而 Svetle 在这里采用了 `{` 和 `}` 作为差值表达式的标记，并进行了扩展，提供了更加丰富的控制指令。
本书也以此为基础，这里先介绍其中最简单的用法，用于满足后文需要。

这里简单举个例子，假设存在一个变量，名为 `name`，将其显示到如下的模板中：

<md-code ref="02/intersection.html"></md-code>

此时当 `name` 为 `Bill` 的时候，渲染的结果为 `<div>Hello Bill</div>`。
而当 `name` 为 `Bob` 的时候，渲染结果就变为 `<div>Hello Bob</div>`。

当模板渲染的内容跟随变量 `name` 变化而变化，这就差值表达式的作用。

## 变量定义

在了解了有关插值表达式相关的基础之后，就引申出了另一个问题，表达式有了，那变量从哪里读取呢？

不同的框架对此有着不同的处理方式：

- Vue 会将表达式的作用域绑定在 Script 脚本内所返回的 Vue 实例上
- React 会将表达式的作用域绑定在脚本执行位置所对应的作用域
- Angular 则将表达式的作用域绑定在对应的 Component 实例上

不了解上述其他的框架没关系，让我们来看 Svelte，其采用了一个非常巧妙设计，来上代码

<md-code ref="02/simple.html"></md-code>

可以看到，差值表达式与 `<script>` 标签内的 `name` 变量定义处于一个作用域内。之所以说这是一个非常巧妙的设计，主要在于：

- 直观易懂，即使你一点都不了解 Svelte，只需要知道基础的 JS 语法，在看到这个模板的时候，也可以了解其作用含义
- 上手成本低，没有任何其他框架所带来的的范式，在设计中尽可能复用了 JS 语法中的优秀能力
- 嘈杂信息少，模板内容非常简单，几乎除了这对 `<script>` 标签外，没有任何无用的样板代码

## 创建

让我们复用上面例子中的模板，继续后面的步骤。
可以想到，如果想要在 `createBlock` 的时候能够获取到 `name` 变量的值，只需要将其在构建的时候传入到方法内即可。
于是可以很轻松的写出如下的代码：

<md-code ref="02/simple-create.ts"></md-code>

很轻松，我们就实现了如何渲染一个差值表达式。

> 当前例子中的差值表达式其实就是获取一个变量的值，在这里并不去介绍更多更复杂的表达式，也不会深入讲解如何将差值表达式变成对应的 JavaScript 脚本。这些属于扩展阅读部分。

<md-todo>放入一个差值表达式解析的链接</md-todo>

## 动态更新

虽然我们引入了插值表达式，上文也实现了如何真正将插值表达式渲染出来，可是作为差值表达式最重要的一个功能——「动态更新」却还没有实现。没有这个能力，也就失去了其最大的意义和价值。

而如何让差值表达式更新呢？Svelte 设计了一套基于赋值操作的更新逻辑，例如下面这个例子

<md-code ref="02/simple-update.html"></md-code>

一开始会渲染为 `Hello foo`，1s 之后，`name` 变量被 `=` 赋值操作符更新为了 `"bar"`，此时 Svelte 遇到这个操作符的时候会认为需要重新去更新左值所对应的变量的插值表达式了，最终将模板更新为 `Hello bar`

而如何实现更新这个过程呢？

目前 Block 已经返回了 `mount`/`destroy` 两个生命周期方法，是不是应该再多一个 update 生命周期方法呢？答案确实是如此，而且思路就是这么简单。

<md-code diff="02/simple-create.ts,02/simple-update.ts"></md-code>

当我们完成了创建的能力之后，更新逻辑照葫芦画瓢也能知道，只需要重新根据变量参数计算一次 `innerText` 值即可。说干就干

更新是一个独立的流程，所以需要额外添加一个新的 `update` 函数，专门用于处理和更新逻辑相关的代码，其入参为我们需要的变量值。

<md-code diff="02/multi-var.ts,02/update-multi-var.ts"></md-code>

至此，我们便可以实现让其整体动起来的目标了。

## 总结

本章节我们了解了什么是插值表达式以及如何使用插值表达式，以及模板存在插值表达式的情况下如何渲染和更新模板。

但这一切都仅仅围绕着一个 `name` 变量所展开，但如果变量数量增多，又会产生什么样子的问题呢？这个是下一章节索要探讨的内容。
