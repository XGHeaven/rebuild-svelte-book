# 响应式更新

在前几篇中，我们已经完成了对基础更新能力的认识，但仅仅用那些实现的更新距离一个真正可用好用的框架还有很远的距离。那么本篇便要开始进入 Svelte 至关重要的更新检查逻辑了。这也是 Svelte 区别于其他框架一个很重要的不同。

## 什么是响应式更新

在前文的例子中，我们可以看到，一旦某个变量发生了变化，会触发 `update` 函数，从而将所有相关的所有内容都更新一遍。
众所周知，DOM 的更新是极其昂贵的，即使是利用 TextNode 节点去尽量避免更新全部内容，但只要是有插值表达式的地方，依旧需要被更新一次。

虽然针对这个情况，我们可以在执行 DOM 更新操作之前，对比一下新旧是否有发生变化，虽然可以避免昂贵的 DOM 操作。
但依旧无法避免需要将全部的插值表达式重新计算一遍。

换句话说，「更新」逻辑并没有跟随感知到变量所发生的变化，进而无法判断某个插值表达式是否需要重新计算并更新。
为了弥补这个能力，「响应式更新」应运而生。正所谓自如其名，「响应式」响应的便是变量，某次更新过程，可以清楚的感知到某个变量究竟有没有发生变化，如果某个变量没有发生变化，那么完全可以不需要重新计算与这个变量相关的表达式。

因此响应式更新也可以叫做**精准更新**，因为相比之前粗犷的更新方式，确实要「精准」不少。虽然两者在语义上其实不是完全一致，但是在大部分场合下，都可以可以互相替代，所以后文不再区分两者（绝不是作者懒，想少写一个字。

要想实现对应的精准更新的逻辑，需要我们理解其中重要的三个逻辑：

- 发现，发现究竟是哪个变量发生了更新
- 记录，记录哪个变量更新了
- 判断，判断究竟是哪个插值表达式应该需要被更新

这三者是缺一不可，接下来我们一一讲解。

## 变更「发现」

如何得知一个变量发生了变更，虽然说起来简单，但却一直没有一个合适的解决方案。

例如 Vue，他劫持了 `data` 对象上所有属性的 getter/setter 从而可以在开发者赋值的时候感知到某个变量究竟发生了什么变化。
而 React 则选择了躺平，老子才不关心你啥变量更新了，只要你调用了 `setState` 我通通认为这个组件需要更新。当然这也与其使用了 VirtualDOM 相关，毕竟更新剪枝的操作都放在了这个时候去执行，所以前置无需再考虑这些事情。

而 Svelte 该怎么设计呢？首先要没有繁重的运行时，这就 pass 掉劫持对象属性的方案了，自然 VirtualDOM 也不能使用。既然没有运行时，那么只依赖编译器可不可以呢？

答案是，可以，但很难。为什么这么说呢？因为运行时是足够灵活的，有一万种方法绕过让编译无法感知到你究竟有没有在更新变量。
例如最简单的，利用函数更新某个对象的值，或者利用 `Object.assign`。
但有句老话说的好——「框架做不了，自有开发者来干」。

其实在框架的设计中，充满了类似于这种框架想做但是又没法做的情况，也就是说做不到最完美。
那么此时就需要学会取舍，不管是那种方案，都会有着无法覆盖的情况，那么此时我们更多的可以关注到大家经常使用的场景上来。

大部分开发者在更新变量的时候，使用的最多的其实就是赋值语句。那么 Svelte 顺水推舟，将赋值语句作为发现的单位，似乎就能覆盖大部分场景。
即使开发者使用了其他 Svelte 无法感知的更新方式，也可以通过简单的 `a=a` 的赋值语句来告知 Svelte 变量 `a` 发生了变更。
而且这部分在编译期间就可以直接被优化掉，也不用担心多出来的这个语句带来额外的性能消耗。

至此，便可以设计出通过检测赋值语句来发现变更的设计思路。可以见如下模板

<md-code ref="./detect.html" id="code-detect"></md-code>

> 不过这个方案实际上除了上面所讲的弊端，还有很多的问题需要处理。
> 例如：
>
> - 如何区分 `a=a` 中 `a` 究竟是模板中的变量还是本地变量
> - 如何处理 `a[b] = xxx` 这种带成员索引的赋值语句
> - 要不要处理解构之后的赋值语句，`const {foo} = a; foo.bar = xxx`
>
> 这些内容如何处理，其实是编译侧的问题，本书这部分的关注点主要在编译的结果，而不是编译的过程，就不在这里详叙了。
后文也会有提到相关内容，但仅仅蜻蜓点水一下，有兴趣的同学可以去看下[这部分 Svelte 的源码](https://github.com/sveltejs/svelte/tree/master/src/compiler)。

## 变更「记录」

当我们得知了某个变量发生了变更的时候，如何将其记录下来呢？

最简单的检测赋值语句得知的某个变量会发生变化的时候，便是将其 push 到一个数组内即可，例如 `changed.push('foo')` 添加到数组中，当需要判断某个变量存不存在的时候，直接 `changed.indexOf(varName) !== -1` 即可。

于是可以改写<md-link href="#code-detect">上段的 demo</md-link>

<md-code ref="./var-record.ts"></md-code>

## 变更「判断」

## TODO

如何理解精准更新呢？让我们先来看下面这个例子

<md-code ref="04/init.html"></md-code>

这里我们引入了三个变量，按照以前的管理，我们可以得到如下代码

<md-code ref="04/init.ts"></md-code>

此时，如果一旦发生更新就会发现，即使是其中一个变量发生了变化，调用 `update` 函数之后，所有的值都需要被更新。当变量越多的时候，所需要发生更新元素就会越多。这对于一个框架的实现来说显然是不可承受的。

因此，根据具体变量的变化更新对应的插值，就是所谓的精准更新。

## 扩展：响应式更新只有监听变量这一种方式么？

在继续之前，我们还需要先想明白一个事情，就是精准更新究竟是针对是插值还是变量？
或许有的人会好奇，这两者不是一样的么？
其实从开始到现在所举的例子中，确实是一样的，因为一个插值中只使用了一个变量，变量一旦变化了，那么插值就一定跟随变化。
但是事实中的情况就复杂许多，如果我们有如下这样的模板，就会发现其实是不一样的。

<md-code ref="04/var-or-inter.html"></md-code>

此模板中一共有三个插值，分别表示「i1: 当前小时」、「i2: 增加小时」、「i3: 增加后小时」。

首先精准更新若是发生在变量这个层级上，也就是说如果 `delta` 发生了变化，我们能够知道 `i2` 与 `i3` 是需要被更新的，因为这两个插槽都用到了这个变量。但是 `i1` 并不需要，因为他没有用到这个变量。此时就算是 `delta` 从 `0` 变为了 `24`，导致 `i3` 没有任何变化（因为有求余的存在），在变量更新的视角下，此时依旧需要尝试去更新插值。

可以观察到，就算是变量更新了，依旧是需要计算出插值的值，那么如果我们不关心插值和变量之间的关系，而是只关系发生在插值这个层级上的变化的话，一切似乎都变得非常简单了，因为不再需要维护他们之前的关系链了。如果 `delta` 发生了变化，我们并不知道究竟谁需要去更新，此时需要将 `i1`/`i2`/`i3` 全部重新计算一遍，得到最新的 `i1'`/`i2'`/`i3'`。此时就可以对比前后插值是否有发生变化。如果一旦 `delta` 发生了从 `0` 到 `24` 的变更，站在插值这个角度看待，就会发现只有 `i2` 需要更新，因为 `i3` 前后的值是一样的。

这两种方案其实各有优劣：

| 类型 | 优势                                                       | 缺点                                                                       |
| ---- | ---------------------------------------------------------- | -------------------------------------------------------------------------- |
| 变量 | 能够建立变量与插值之间的关系，可以做到准确更新             | 需要维护关系链，可能在某些场景下性能会被严重拖累                           |
| 插值 | 不关心变量的变化与使用，只关心最终的插值的值是否发生了变化 | 每次更新都需要全量重新计算一次所有的插值，如果一旦插值内容过多，性能会很差 |

其实业界大部分框架其实都是采用了类似于插值对比的方案，比如 React/Vue，只不过这些框架对比的对最后生成的 VNode 节点，而非我们这里提到的字符串插值。当然也是有直接对比字符串插值的，例如 Lit。

另外这里说到 Vue 其实是比较特殊的一个存在，Vue 本身建立了关系链，只不过关联的不再是变量与插值，而是变量与组件，这其实是一个非常有趣又耐人寻味的设计。有兴趣的可以去研究下。

而，如果我们继续沿着传统思路去设计，那其实就失去了意义了。而这也就是为什么 Svetle 可以诞生的原因，TODO
