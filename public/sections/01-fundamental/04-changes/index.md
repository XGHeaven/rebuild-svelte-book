# 响应式更新

在前几篇中，我们已经完成了对基础更新能力的认识，但仅仅用那些实现的更新距离一个真正可用好用的框架还有很远的距离。那么本篇便要开始进入 Svelte 至关重要的更新检查逻辑了。这也是 Svelte 区别于其他框架一个很重要的不同。

## 什么是响应式更新

在前文的例子中，我们可以看到，一旦某个变量发生了变化，会触发 `update` 函数，从而将所有相关的所有内容都更新一遍。
众所周知，DOM 的更新是极其昂贵的，即使是利用 TextNode 节点去尽量避免更新全部内容，但只要是有插值表达式的地方，依旧需要被更新一次。

虽然针对这个情况，我们可以在执行 DOM 更新操作之前，对比一下新旧是否有发生变化，虽然可以避免昂贵的 DOM 操作。
但依旧无法避免需要将全部的插值表达式重新计算一遍。

换句话说，「更新」逻辑并没有跟随感知到变量所发生的变化，进而无法判断某个插值表达式是否需要重新计算并更新。
为了弥补这个能力，「响应式更新」应运而生。正所谓自如其名，「响应式」响应的便是变量，某次更新过程，可以清楚的感知到某个变量究竟有没有发生变化，如果某个变量没有发生变化，那么完全可以不需要重新计算与这个变量相关的表达式。

因此响应式更新也可以叫做**精准更新**，因为相比之前粗犷的更新方式，确实要「精准」不少。虽然两者在语义上其实不是完全一致，但是在大部分场合下，都可以可以互相替代，所以后文不再区分两者（绝不是作者懒，想少写一个字。

## 如何设计呢？

如果想要实现精准更新的效果，我们就需要明确我们要做到的底层目标是什么。

首先精准更新的目标就是为了做到 DOM 更新集合（也可以叫做更新指令）的最小化，如果发生了变化才会更新，不变化就没有必要进行更新。
而 DOM 是否更新其实是被插值表达式所控制，于是问题就可以转化为如何确定最小的插值表达式更新集合，
又因为插值表达式的结果其实被内部所使用的变量所控制，于是这个问题就又可以转化为如何获取最小的变量更新集合。

<md-todo>可以插一个图</md-todo>

于是我们的目标就变成了如何获取最小的变量更新集合，再根据这个集合计算不同插值表达式的值并更新 DOM。
这个部分可以简单的分为三个逻辑：

- 发现，找到那些变量真正发生了变化
- 记录，记录变量的变化信息
- 更新，变量更新集合更新对应的 DOM 元素

这三者是缺一不可，接下来我们一一讲解。


<md-note type="question">

<md-note-title>

既然知道了某个变量发生了变化，那直接更新变量所对应的 DOM 元素就可以了，为什么一定需要「记录」这个步骤呢？

</md-note-title>

其实这个问题很好回答，因为插值表达式不会仅仅只依赖一个变量，很有可能会同时使用多个。
此时如果采用发现一个就更新一个的策略，很有可能造成更多的更新，这就起不到我们预期内的效果了。

例如某一个插值表达式是 `{a + b}`。让 `a`/`b` 更新，那么当更新 `a` 的时候发现应该更新触发 DOM 更新，而再更新 `b` 的时候也会触发 DOM 更新。
结果就是明明只需要更新 1 次 DOM 的操作结果变成了 2 次，实际上除此之外，可能还会有更糟的情况产生。

例如 `a` 从 0 变成了 2，而 `b` 从 2 变成了 0，此时预期不应该触发任何一次更新，因为 `a + b` 没有发生任何变化，但实际上也会触发两次更新，原因和上面的方法一致。

但如果采用先「记录」后「更新」的策略，就可以避免出现这样的问题了。

或许你在想就算我不记录，也肯定有别的办法实现。我的答案是：对，没错，一定有。
记录的本质是为了创建一个集合信息用于去除掉无用的操作，不管怎么样，这个集合是一定存在的。
就算不在这个地方，也会存在于其他的地方，所以如果想要省却掉这个集合来提升更新速度是不切实际的。

</md-note>

### 「发现」

如何得知一个变量发生了变更，虽然说起来简单，但却一直没有一个合适的解决方案。

例如 Vue，他劫持了 `data` 对象上所有属性的 getter/setter 从而可以在开发者赋值的时候感知到某个变量究竟发生了什么变化。
而 React 则选择了躺平，老子才不关心你啥变量更新了，只要你调用了 `setState` 我通通认为这个组件需要更新。当然这也与其使用了 VirtualDOM 相关，毕竟更新剪枝的操作都放在了这个时候去执行，所以前置无需再考虑这些事情。

而 Svelte 该怎么设计呢？首先要没有繁重的运行时，这就 pass 掉劫持对象属性的方案了，自然 VirtualDOM 也不能使用。既然没有运行时，那么只依赖编译器可不可以呢？

答案是，可以，但很难。为什么这么说呢？因为运行时是足够灵活的，有一万种方法绕过让编译无法感知到你究竟有没有在更新变量。
例如最简单的，利用函数更新某个对象的值，或者利用 `Object.assign`。
但有句老话说的好——「框架做不了，自有开发者来干」。

其实在框架的设计中，充满了类似于这种框架想做但是又没法做的情况，也就是说做不到最完美。
那么此时就需要学会取舍，不管是那种方案，都会有着无法覆盖的情况，那么此时我们更多的可以关注到大家经常使用的场景上来。

大部分开发者在更新变量的时候，使用的最多的其实就是赋值语句。那么 Svelte 顺水推舟，将赋值语句作为发现的单位，似乎就能覆盖大部分场景。
即使开发者使用了其他 Svelte 无法感知的更新方式，也可以通过简单的 `a=a` 的赋值语句来告知 Svelte 变量 `a` 发生了变更。
而且这部分在编译期间就可以直接被优化掉，也不用担心多出来的这个语句带来额外的性能消耗。

至此，便可以设计出通过检测赋值语句来发现变更的设计思路。可以见如下模板

<md-code ref="./detect.html" id="code-detect"></md-code>

> 不过这个方案实际上除了上面所讲的弊端，还有很多的问题需要处理。
> 例如：
>
> - 如何区分 `a=a` 中 `a` 究竟是模板中的变量还是本地变量
> - 如何处理 `a[b] = xxx` 这种带成员索引的赋值语句
> - 要不要处理解构之后的赋值语句，`const {foo} = a; foo.bar = xxx`
>
> 这些内容如何处理，其实是编译侧的问题，本书这部分的关注点主要在编译的结果，而不是编译的过程，就不在这里详叙了。
后文也会有提到相关内容，但仅仅蜻蜓点水一下，有兴趣的同学可以去看下[这部分 Svelte 的源码](https://github.com/sveltejs/svelte/tree/master/src/compiler)。

### 「记录」

一旦得知某个变量发生了变更，需要将这个变化记录下来，方便进一步执行更新检查。

最简单的检测赋值语句得知的某个变量会发生变化的时候，便是将其 push 到一个数组内即可，例如 `changed.push('foo')` 添加到数组中，后续需要判断某个变量存不存在的时候，直接 `changed.indexOf(varName) !== -1` 即可。

于是可以改写<md-link href="#code-detect">上段的 demo</md-link>

<md-code ref="./var-record.ts"></md-code>

### 「更新」

这段代码中只有两个插值表达式，分别是 `{a}` 和 `{b}`，由此在编译期间就可以得知当 `a` 发生变量的时候需要更新前者的差值，当 `b` 发生变化的时候需要更新后者的插值。

于是根据上一步记录下来的变更信息，就可以直接拿来作为是否更新检查的依据了。

<md-code ref="./var-update.ts"></md-code>

当这一步做完之后，Svelte 响应式更新的核心逻辑就完成了，对，其实就是这么简单。
虽然实际上还有很多其他的情况需要去处理，这部分我们放到后面再去讲解。

## 扩展：响应式更新只有监听变量这一种方式么？

在继续之前，我们还需要先想明白一个事情，就是精准更新究竟是针对是插值还是变量？
或许有的人会好奇，这两者不是一样的么？
其实从开始到现在所举的例子中，确实是一样的，因为一个插值中只使用了一个变量，变量一旦变化了，那么插值就一定跟随变化。
但是事实中的情况就复杂许多，如果我们有如下这样的模板，就会发现其实是不一样的。

<md-code ref="./var-or-inter.html"></md-code>

此模板中一共有三个插值，分别表示「i1: 当前小时」、「i2: 增加小时」、「i3: 增加后小时」。

首先精准更新若是发生在变量这个层级上，也就是说如果 `delta` 发生了变化，我们能够知道 `i2` 与 `i3` 是需要被更新的，因为这两个插槽都用到了这个变量。但是 `i1` 并不需要，因为他没有用到这个变量。此时就算是 `delta` 从 `0` 变为了 `24`，导致 `i3` 没有任何变化（因为有求余的存在），在变量更新的视角下，此时依旧需要尝试去更新插值。

可以观察到，就算是变量更新了，依旧是需要计算出插值的值，那么如果我们不关心插值和变量之间的关系，而是只关系发生在插值这个层级上的变化的话，一切似乎都变得非常简单了，因为不再需要维护他们之前的关系链了。如果 `delta` 发生了变化，我们并不知道究竟谁需要去更新，此时需要将 `i1`/`i2`/`i3` 全部重新计算一遍，得到最新的 `i1'`/`i2'`/`i3'`。此时就可以对比前后插值是否有发生变化。如果一旦 `delta` 发生了从 `0` 到 `24` 的变更，站在插值这个角度看待，就会发现只有 `i2` 需要更新，因为 `i3` 前后的值是一样的。

这两种方案其实各有优劣：

| 类型 | 优势                                                       | 缺点                                                                       |
| ---- | ---------------------------------------------------------- | -------------------------------------------------------------------------- |
| 变量 | 能够建立变量与插值之间的关系，可以做到准确更新             | 需要维护关系链，可能在某些场景下性能会被严重拖累                           |
| 插值 | 不关心变量的变化与使用，只关心最终的插值的值是否发生了变化 | 每次更新都需要全量重新计算一次所有的插值，如果一旦插值内容过多，性能会很差 |

其实业界大部分框架其实都是采用了类似于插值对比的方案，比如 React/Vue，只不过这些框架对比的对最后生成的 VNode 节点，而非我们这里提到的字符串插值。当然也是有直接对比字符串插值的，例如 Lit。

另外这里说到 Vue 其实是比较特殊的一个存在，Vue 本身建立了关系链，只不过关联的不再是变量与插值，而是变量与组件，这其实是一个非常有趣又耐人寻味的设计。有兴趣的可以去研究下。

而，如果我们继续沿着传统思路去设计，那其实就失去了意义了。而这也就是为什么 Svetle 可以诞生的原因，TODO
