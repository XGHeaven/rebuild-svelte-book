# 点对点，精准更新

在上文中，我们完成了更新能力的构建，但相信眼尖的同学一定能够发现，一旦变量或者表达式多起来了，那么更新性能也会得到下降，因为只要其中的一个变量发生了变化，都会导致整体的重新更新。

## 背景

如何理解精准更新呢？让我们先来看下面这个例子

<md-code ref="04/init.html"></md-code>

这里我们引入了三个变量，按照以前的管理，我们可以得到如下代码

<md-code ref="04/init.ts"></md-code>

此时，如果一旦发生更新就会发现，即使是其中一个变量发生了变化，调用 `update` 函数之后，所有的值都需要被更新。当变量越多的时候，所需要发生更新元素就会越多。这对于一个框架的实现来说显然是不可承受的。

因此，根据具体变量的变化更新对应的插值，就是所谓的精准更新。

## 更新的到底是谁？

在实现精准之前，我们需要先想明白，我们想要精准更新的是插值还是变量？或许有的人会好奇，这两者不是一样的么？其实从开始到现在所举的例子中，确实是一样的，因为一个插值中只使用了一个变量，但是事实中的情况就复杂许多，如果我们有如下这样的模板，就会发现其实是不一样的。

<md-code ref="04/var-or-inter.html"></md-code>

此模板中一共有三个插值，分别表示「i1: 当前小时」、「i2: 增加小时」、「i3: 增加后小时」。

首先精准更新若是发生在变量这个层级上，也就是说如果 `delta` 发生了变化，我们能够知道 `i2` 与 `i3` 是需要被更新的，因为这两个插槽都用到了这个变量。但是 `i1` 并不需要，因为他没有用到这个变量。此时就算是 `delta` 从 `0` 变为了 `24`，导致 `i3` 没有任何变化（因为有求余的存在），在变量更新的视角下，此时依旧需要尝试去更新插值。

可以观察到，就算是变量更新了，依旧是需要计算出插值的值，那么如果我们不关心插值和变量之间的关系，而是只关系发生在插值这个层级上的变化的话，一切似乎都变得非常简单了，因为不再需要维护他们之前的关系链了。如果 `delta` 发生了变化，我们并不知道究竟谁需要去更新，此时需要将 `i1`/`i2`/`i3` 全部重新计算一遍，得到最新的 `i1'`/`i2'`/`i3'`。此时就可以对比前后插值是否有发生变化。如果一旦 `delta` 发生了从 `0` 到 `24` 的变更，站在插值这个角度看待，就会发现只有 `i2` 需要更新，因为 `i3` 前后的值是一样的。

这两种方案其实各有优劣：

| 类型 | 优势                                                       | 缺点                                                                       |
| ---- | ---------------------------------------------------------- | -------------------------------------------------------------------------- |
| 变量 | 能够建立变量与插值之间的关系，可以做到准确更新             | 需要维护关系链，可能在某些场景下性能会被严重拖累                           |
| 插值 | 不关心变量的变化与使用，只关心最终的插值的值是否发生了变化 | 每次更新都需要全量重新计算一次所有的插值，如果一旦插值内容过多，性能会很差 |

其实业界大部分框架其实都是采用了类似于插值对比的方案，比如 React/Vue，只不过这些框架对比的对最后生成的 VNode 节点，而非我们这里提到的字符串插值。当然也是有直接对比字符串插值的，例如 Lit。

另外这里说到 Vue 其实是比较特殊的一个存在，Vue 本身建立了关系链，只不过关联的不再是变量与插值，而是变量与组件，这其实是一个非常有趣又耐人寻味的设计。有兴趣的可以去研究下。

而，如果我们继续沿着传统思路去设计，那其实就失去了意义了。而这也就是为什么 Svetle 可以诞生的原因，TODO

## 更新变化 Changes
